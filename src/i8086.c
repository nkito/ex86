#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <signal.h>
#include <ctype.h>

#include "i8086.h"
#include "misc.h"
#include "logfile.h"
#include "terminal.h"
#include "mem.h"

#include "mainloop.h"

#ifndef DEBUG
int DEBUG = 0;
#endif


int main(int argc, char *argv[]){
    struct stMachineState ms;
    struct stEmuSetting emu;
    struct stMemIORegion memIo;

    memset(&ms,    0, sizeof(ms));
    memset(&emu,   0, sizeof(emu));
    memset(&memIo, 0, sizeof(memIo));

    ms.pEmu   = &emu;
    ms.pMemIo = &memIo;

    ms.pEmu->breakPoint    = EMU_MEM_SIZE;
    ms.pEmu->breakMask     = ~0;
    ms.pEmu->runAfterBreak = 10;
    ms.pEmu->breakCounter  = 0;
    ms.pEmu->emu_cpu       = EMU_CPU_80186;

    //-----------------------------------------------------
    // Reset the CPU register and set pointers for CPU registers
    //-----------------------------------------------------
    ms.reg.eip           = 0x0000fff0;
    ms.reg.cs            = 0xf000;
    ms.reg.descc_cs.base = 0xf0000;
    ms.reg.eflags        = 0x00000000;

    ms.reg.fetchCacheBase= FETCH_CACHE_BASE_INVALID;

    ms.reg.descc_es.limit = ms.reg.descc_es.limit_max = 0xffff; ms.reg.descc_es.writable = 1;
    ms.reg.descc_cs.limit = ms.reg.descc_cs.limit_max = 0xffff; ms.reg.descc_cs.readable = 1;
    ms.reg.descc_ss.limit = ms.reg.descc_ss.limit_max = 0xffff; ms.reg.descc_ss.writable = 1;
    ms.reg.descc_ds.limit = ms.reg.descc_ds.limit_max = 0xffff; ms.reg.descc_ds.writable = 1;
    ms.reg.descc_fs.limit = ms.reg.descc_fs.limit_max = 0xffff; ms.reg.descc_fs.writable = 1;
    ms.reg.descc_gs.limit = ms.reg.descc_gs.limit_max = 0xffff; ms.reg.descc_gs.writable = 1;

    ms.reg.eax  = 0x12345678;
    if( ms.reg.ax[FIRST_WORD_IDX_IN_DWORD] != 0x5678 ){
        fprintf(stderr, "Wrong byte order seems to be specified in compiling time. Please recompile it with the correct byte order setting.\n");
        exit(1);
    }
    ms.reg.eax  = 0x0;

    //-----------------------------------------------------
    // initializing the memory system and debugging feature
    //-----------------------------------------------------
    ms.pEmu->watchAddr       = EMU_MEM_SIZE; // watch is disabled

    ms.pEmu->log_enabled_cat = (LOGCAT_EMU | LOGCAT_CPU_EXE);
    ms.pEmu->log_level       = LOGLV_DISABLE_LOG; // log file is not generated by default

    ms.pMemIo->ioSysCtrlB    = 0;
    /*
    ms.pMemIo->ioPICmain.init = 0;
    ms.pMemIo->ioPICsub .init = 0;
    ms.pMemIo->ioPICmain.seqn = 0;
    ms.pMemIo->ioPICsub .seqn = 0;
    */

    initEmulator(&ms, argc, argv);

    // clear display area (it clears the screen immidiately)
    for(uint32_t i = 0; i< 80*25; i++){
        writeDataMemByte(&ms, 0xb8000 + 2*i+0, ' ');
        writeDataMemByte(&ms, 0xb8000 + 2*i+1, 0x08); // color
    }

    //-----------------------------------------------------
    // Reset the terminal color for serial console programs such as monitors
    //-----------------------------------------------------
    termResetColor();
    termResetBlink();
    //-----------------------------------------------------

    logfile_init( ms.pEmu->log_enabled_cat, ms.pEmu->log_level);
    logfile_printf(LOGCAT_EMU | LOGLV_NOTICE, "------------------------\n");
    logfile_printf(LOGCAT_EMU | LOGLV_NOTICE, "Starting the emulator...\n");

    if(DEBUG){
        logfile_printf(LOGCAT_EMU | LOGLV_NOTICE, "Debug mode\n");
    }

    if(ms.pEmu->breakPoint < EMU_MEM_SIZE){
        logfile_printf(LOGCAT_EMU | LOGLV_NOTICE, "Breakpoint        : 0x%x\n", ms.pEmu->breakPoint);
        logfile_printf(LOGCAT_EMU | LOGLV_NOTICE, "#insts after break: %d\n",   ms.pEmu->runAfterBreak);
    }

    saveTerminalSetting(&ms);
    initTerminalSetting(&ms);

    if( ms.pEmu->emu_cpu == EMU_CPU_80186 || ms.pEmu->emu_cpu == EMU_CPU_8086 ){
        mainloop16(&ms);
    }else if( ms.pEmu->emu_cpu == EMU_CPU_80386 ){
        mainloop32(&ms);
    }

    restoreTerminalSetting(&ms);
    termResetSettingForExit();

    logfile_close();

/*
    if( eflag ){
        printf("Interrupt...\n");
    }
*/

    return 0;
}

